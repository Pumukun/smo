# -*- coding: utf-8 -*-
"""Copy of SMO_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yH854VN52S2HehyYASXe6z4jJ5iBQFCt
"""

n = 6 #(5)
m = 13 #(5)
deltaT_z = 0.724
T_ob = 0.738
lamda = 1.142 #(5)
mu_1 = 1.412
mu_2 = 0.235 #(5)

import numpy as np

def rfind(arr, item):
  b = list(reversed(arr))
  return len(arr) - b.index(item) - 1

def min_not_null(arr):
  m = 9999999
  for i in range(len(arr)):
    if(arr[i] < m)and(arr[i] != 0):
      m = arr[i]
  return m

t_z = round(np.random.exponential(1/lamda), 5)
t_ob = round(np.random.exponential(1/mu_2), 5)
och = []

prib_time = []
prib_z = []
for i in range(100):
  prib_time.append([])
  prib_z.append([])
  for j in range(n):
    prib_time[i].append(0)
    prib_z[i].append(0)

prib_time[0][0] = t_ob
prib_z[0][0] = 1

l = [1]
t_sob = [t_z]
Type = [1]
C_l = [1]
t_osmin = [t_ob]
t_ozh = [round(np.random.exponential(1/lamda), 5)]
j_l = [1]
k_l = [1]

for i in range(1, 100):
  if och != []:
    print(och)
  l.append(i + 1)
  if(t_osmin[i-1] < t_ozh[i-1] and t_osmin[i-1] != -1): # Завершение обработки
    t_sob.append(round(t_sob[i-1] + t_osmin[i-1], 5))
    delta_t = t_sob[i] - t_sob[i-1]
    Type.append(2)
    C_l.append(C_l[i-1] - 1)
    for j in range(n):
      if(prib_time[i-1][j] != 0):
        prib_time[i][j] = round(prib_time[i-1][j] - delta_t, 5)
        prib_z[i][j] = prib_z[i-1][j]
    if(C_l[i] != 0):
      t_osmin.append(min_not_null(prib_time[i]))
    else:
      t_osmin.append(-1)
    t_ozh.append(round(t_ozh[i-1] - t_osmin[i-1], 5))
    j_l.append(prib_z[i][prib_time[i-1].index(min_not_null(prib_time[i-1]))])
    prib_z[i][prib_time[i-1].index(min(prib_time[i-1]))] = 0
    k_l.append(prib_time[i-1].index(min_not_null(prib_time[i-1])) + 1)
    if(och != []):
      prib_time[i][k_l[i]] = round(np.random.exponential(1/mu_2), 5)
      prib_z[i][k_l[i]] = och.pop(0)

  else: # Появление новой заявки
    t_sob.append(round(t_sob[i-1] + t_ozh[i-1], 5))
    delta_t = t_sob[i] - t_sob[i-1]
    for j in range(n):
      if(prib_time[i-1][j] != 0):
        prib_time[i][j] = round(prib_time[i-1][j] - delta_t, 5)
        prib_z[i][j] = prib_z[i-1][j]
    if(len(och) == m):
      Type.append(2)
      C_l.append(C_l[i-1])
      t_osmin.append(min_not_null(prib_time[i]))
      k_l.append(-1)
    else:
      Type.append(1)
      C_l.append(C_l[i-1] + 1)
      if (t_osmin[i-1] != -1):
        if(min(prib_time[i]) == 0):
          k_l.append(prib_time[i].index(0) + 1)
          prib_time[i][k_l[i]-1] = round(np.random.exponential(1/mu_2), 5)
          prib_z[i][k_l[i]-1] = max(j_l) + 1
        else:
          k_l.append(-1)
          och.append(max(j_l) + 1)
        t_osmin.append(min_not_null(prib_time[i]))
      else:
        t_osmin.append(round(np.random.exponential(1/mu_2), 5))
        prib_time[i][0] = round(t_osmin[i], 5)
        prib_z[i][0] = 1
        k_l.append(1)
    t_ozh.append(round(np.random.exponential(1/lamda), 5))
    j_l.append(max(j_l) + 1)

#print(l)
#print(t_sob)
#print(Type)
#print(C_l)
#print(t_osmin)
#print(t_ozh)
#print(j_l)
#print(k_l)

print("l;t_sob;Type;C_l;t_osmin;t_ozh;j_l;k_l")
for i in range(100):
  print(f"{l[i]};{t_sob[i]};{Type[i]};{C_l[i]};{t_osmin[i]};{t_ozh[i]};{j_l[i]};{k_l[i]}")

j = []
t_z = []
q_j = []
t_och = []
t_nob = []
t_obsl = []
t_kob = []
k_j = []

for i in range(1, max(j_l) + 1):
  j.append(i)
  t_z.append(t_sob[j_l.index(i)])

  for k in range(100):
      if(i in prib_z[k]):
        t_nob.append(t_sob[k])
        t_och.append(round(t_nob[i-1] - t_z[i-1], 5))
        k_j.append(prib_z[k].index(i) + 1)
        t_kob.append(t_sob[rfind(j_l, i)])
        if(t_kob[i-1] == t_nob[i-1]):
          t_kob[i-1] = -1
          t_obsl.append(-1)
        else:
          t_obsl.append(round(t_kob[i-1] - t_nob[i-1], 5))
        break

  if(C_l[j_l.index(i)] > n):
    q_j.append(C_l[j_l.index(i)] - n)
  else:
    q_j.append(0)

#print(j)
#print(t_z)
#print(q_j)
#print(t_och)
#print(t_nob)
#print(t_obsl)
#print(t_kob)
#print(k_j)

print("j;t_z;q_j;t_och;t_nob;t_obsl;t_kob;k_j")
for i in range(len(j)):
  print(f"{j[i]};{t_z[i]};{q_j[i]};{t_och[i]};{t_nob[i]};{t_obsl[i]};{t_kob[i]};{k_j[i]}")

k = []
N_k = []
t_zan = [0 for x in range(n)]
t_pr = []
delta_pr = []

for i in range(n):
  k.append(i+1)
  tmp = set()
  for t in range(100):
    if(prib_z[t][i] != 0):
      tmp.add(prib_z[t][i])
  N_k.append(len(tmp))
  tmp = set()
  for t in range(1, 100):
    if(prib_z[t][i] not in tmp):
      t_zan[i] += round(prib_time[t][i], 5)
      tmp.add(prib_z[t][i])
  t_zan[i] = round(t_zan[i], 5)
  if(t_zan[i] > max(t_sob)):
    t_zan[i] = round(max(t_sob), 5)
  t_pr.append(round(max(t_sob) - t_zan[i], 5))
  delta_pr.append(round(t_pr[i] / max(t_sob), 5))
#print(k)
#print(N_k)
#print(t_zan)
#print(t_pr)
#print(delta_pr)

print("k;N_k;t_zan;t_pr;delta_pr")
for i in range(len(k)):
  print(f"{k[i]};{N_k[i]};{t_zan[i]};{t_pr[i]};{delta_pr[i]}")

print(sum(delta_pr) / n)

J = max(j_l)
JF = Type.count(2)
JL = Type.count(3)

z = round(sum(C_l) / 100, 5)
_t_och = round(sum(t_och) / JF, 5)
_t_smo = 0
for i in range(JF):
  _t_smo += round(t_kob[i] - t_z[i], 5)

_t_smo = _t_smo / 100

print("J:", J)
print("JF: ", JF)
print("JL: ", JL)
print("z: ", z)
print("_t_och: ", _t_och)
print("_t_smo: ", _t_smo)